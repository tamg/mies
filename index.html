<!DOCTYPE html>
<html>
<head>
<title>Mies: Vector Editing Tool Using Paper.JS</title>
<link href="./src/stylesheets/style.css" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/emojione/2.2.7/assets/css/emojione.min.css"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.10.3/paper-full.js"></script>
<script src="https://cdn.jsdelivr.net/emojione/2.2.7/lib/js/emojione.min.js"></script>
<script src="./src/js/FileSaver.min.js"></script>
</head>

<body>
<canvas resize id="draw"></canvas>
<script type="text/paperscript" canvas="draw" async>

var currentColor = 'SpringGreen'
var currentStrokeWidth = 3

var previousTool = ''
var currentTool = 'line'
var myPath

//the layer where most things are inside of
var baseLayer = new Layer({
	name: 'baseLayer'
})

//layer to hold the colorwheel tool
var colorWheelLayer = new Layer({
	name: 'colorWheelLayer'
})

//activate baseLayer
baseLayer.activate()

//draw our artboard based on browser window size (view)
var artBoardSize = new Size (900, 600)
var artBoardTopX = Math.max(180,(view.center.x - artBoardSize.width/2))
var artBoardPoint = new Point (artBoardTopX, view.center.y - artBoardSize.height/2)

var artBoard = new Path.Rectangle({
	point: artBoardPoint,
	size: artBoardSize,
	strokeColor: '#cbcbcb',
	strokeWidth: .5,
	fillColor: 'ghostwhite',
	name: 'artboard',
	shadowColor: '#cbcbcb',
	shadowBlur: 30,
	shadowOffset: new Point(10, 10),
})

//draw all the ui elements
var ui = {

	info: new PointText({
		point: artBoardPoint - [0, 10],
		fillColor: 'black',
		fontSize: 24,
		content: 'Click and Drag to draw a line'
	}),

	line: new Path.Line({
		from: [50, 100],
		to: [100, 50],
		strokeWidth: 8,
		strokeColor: 'red',
		onClick: function(event) {
			currentTool = 'line'
			draw.line.activate()
			ui.info.content = 'Click and Drag to draw a ' + currentTool
		}
	}),

	circle: new Path.Circle({
		center: [80, 150],
		radius: 30,
		fillColor: 'red',
		onClick: function(event) {
			currentTool = 'circle'
			draw.circle.activate()
			ui.info.content = 'Click and Drag to draw a ' + currentTool
		}
	}),

	rect: new Path.Rectangle({
		point: [50, 200],
		size: [60,60],
		fillColor: 'red',
		onClick: function(event) {
			currentTool = 'rectangle'
			draw.rectangle.activate()
			ui.info.content = 'Click and Drag to draw a ' + currentTool
		}
	}),

	arc: new Path.Arc({
		from: [50, 320],
		through: [80, 290],
		to: [110, 320],
		strokeColor: 'red',
		strokeWidth: 7,
		onClick: function(event) {
			currentTool = 'arc'
			draw.arc.activate()
			ui.info.content = 'Click and Drag to draw an ' + currentTool
		}
	}),

	cloud: new Path({
		segments:[[50, 370],[60, 350],[70, 370],[80, 350],
		[90, 370],[100, 350],[110,370]],
		strokeColor: 'red',
		strokeWidth: 8,
		onClick: function(event) {
			currentTool = 'cloud'
			draw.cloud.activate()
			ui.info.content = 'Click and Drag to draw a ' + currentTool
		}
	}),

	text: new PointText({
		point: [60, 450],
		fillColor: 'red',
		fontSize: 70,
		fontFamily: 'Arial Bold',
		content: 'T',
		onClick: function(event) {
			currentTool = 'text'
			draw.text.activate()
			ui.info.content = 'Click to insert text and type'
		}
	}),

	transform: new Path({
		segments:[[60, 490],[110, 470],[90, 520], [83, 497]],
		fillColor: 'red',
		onClick: function(event) {
			currentTool = 'transform'
			draw.transform.activate()
			ui.info.content = 'Mouse Drag = Move       Up / Down arrow = Scaling       Space = Delete'
		}
	}),

	color: new Path.Circle({
		center: [80, 570],
		radius: 30,
		fillColor: currentColor,
		strokeColor: 'whitesmoke',
		strokeWidth: 1.5,
		onClick: function(event) {
			previousTool = currentTool
			currentTool = 'color'
			showColorUi()
			draw.color.activate()
			project.layers.colorWheelLayer.visible = true
			ui.info.content = 'Click to pick a color'
		}
	}),

	download: new CompoundPath({
    children: [
        new Path.Circle({
            center: new Point(80, 650),
            radius: 30,
        }),
				new Path.Line({
            segments: [[65,660], [65,667], [95,667], [95,660]],
        }),
				new Path.Line({
            segments: [[70,650], [80,665], [90,650]],
        }),
				new Path.Line({
						segments: [[80,630], [80,665]],
				}),
    ],
		strokeColor: 'red',
		strokeWidth: 3,
		fillColor: 'white',
		onClick: function(event) {
				var exportData = paper.project.exportSVG({ asString: true, bounds: artBoard });
				var blob = new Blob([exportData], {type: "image/svg+xml;charset=" + document.characterSet});
				saveAs(blob, 'fileNameNoExtension' +'.svg');
		}
	}),

	tempColorDisplay: new Path.Line({
		from: artBoard.bounds.bottomLeft,
		to: artBoard.bounds.bottomRight,
		strokeWidth: 20,
		strokeColor: currentColor,
		onClick: function(event) {
				previousTool = currentTool
				currentTool = 'color'
				showColorUi()
				draw.color.activate()
				project.layers.colorWheelLayer.visible = true
				ui.info.content = 'Click to pick a color'
		}
	}),

	created: new PointText({
		position: artBoard.bounds.bottomLeft + [0, +40],
		fillColor: 'red',
		fontSize: 12,
		content: 'Github Source [Created by @tamrrat at The Recurse Center]',
		onClick: function(event) {
			window.open('http://paperjs.org','_blank')
		}
	})

}//window.ui

//add style to cloud and tempColorDisplay ui
ui.cloud.simplify()
ui.tempColorDisplay.position.y += 10

// modified from Paperjs.org examples
// called to show the color wheel
function showColorUi() {

	colorWheelLayer.activate()
	var steps = {
			hue: 24,
			saturation: 5,
			lightness: 3
	}

	var colorGroup = new Group()

	//lightness
	for (var l = 0; l < steps.lightness; l++) {
		var radius = artBoard.size.width / steps.lightness * 0.40
		var offset = new Point(artBoard.size.width / steps.lightness, 0)
		var center = artBoard.bounds.leftCenter + offset * (l + 0.5)
		var lightness = 1 - (l + 1) / (steps.lightness + 1)

		//hue
		var hUnit = 360 / steps.hue
		for (var h = 0; h < steps.hue; h++) {
			var hue = h * hUnit;
			var vector = new Point({
					angle: hue - 90,
					length: radius
			})

			//saturation
			for (var i = 0; i < steps.saturation; i++) {
				var saturation = i / steps.saturation
				var color = { hue: hue, saturation: saturation, lightness: lightness }
			}

			colorPath = new Path(new Point(), vector.rotate(hUnit / 2))
			colorPath.closed = true
			colorPath.arcTo(vector, vector.rotate(hUnit / -2))
			colorPath.position += center

			colorPath.onClick = function(event) {
				currentTool = previousTool
				draw[currentTool].activate()
				project.layers.colorWheelLayer.visible = false
			}

			colorPath.fillColor = colorPath.strokeColor = color
			colorPath.name = 'colorPath' + colorPath.id
			project.layers.colorWheelLayer.addChild(colorPath)
			colorGroup.addChild(colorPath)
		}

	//activate the base layer back after creating colorWheelLayer
	baseLayer.activate()
}
}//showColorUi()

// Group all the UI stuff together
var uiGroup = new Group({
	children: [ui.line, ui.circle, ui.rect, ui.arc, ui.cloud,
		 				 ui.text, ui.transform, ui.color, ui.download]
	//adjust group position based on artboards position
})

//position ui relative to the artboard
uiGroup.position.y = artBoard.position.y
uiGroup.scale(.8)

// helper function to check/clip if a drawn object is inside the bounds of an artBoard
// TODO: figure out layer index issue
function checkIfBoardContains(object) {
	if (!artBoard.bounds.contains(object.bounds)) {
		var clipper = new Path.Rectangle(artBoard.bounds)
		var clippedGroup = new Group(clipper, object)
		clippedGroup.clipped = true
	}
}


//all the drawing and editing tools
window.draw = {
		line: new Tool({
				onMouseDown: function(event) {
							path = new Path();
							path.strokeColor = currentColor
							path.add(event.point)
							path.strokeWidth = currentStrokeWidth
					},
				onMouseDrag: function(event) {
					if(artBoard.bounds.contains(event.point)) {
						path.add(event.point)
					}
				}
		}),

		circle: new Tool({
				onMouseDrag: function(event) {
					if(artBoard.bounds.contains(event.point)) {
						var radius = (event.downPoint - event.point).length
						var circle = new Path.Circle({
								center: event.downPoint,
								radius: radius,
								name: 'circle' + this.id,
								fillColor: currentColor,
								strokeColor: 'black',
						})
						circle.removeOnDrag()
						checkIfBoardContains(circle)
					}
				}
		}),

		rectangle: new Tool({
				onMouseDrag: function(event) {
					if(artBoard.bounds.contains(event.point)) {
							// figure out to do with native rect instead of circle
							var radius = (event.downPoint - event.point).length
							var circle = new Path.Circle(event.downPoint, radius)
							var rect = new Path.Rectangle(circle.bounds)
							rect.fillColor = currentColor
							rect.strokeColor = 'black'
							rect.removeOnDrag()

							checkIfBoardContains(rect)

							circle.remove()
					}
				}
		}),

		arc: new Tool({
				onMouseDown: function(event) {
					 	myPath = new Path() //arc tool
				},
				onMouseDrag: function(event) {
					if(artBoard.bounds.contains(event.point)) {
						myPath = new Path()
						myPath.strokeColor = currentColor
						myPath.strokeWidth = currentStrokeWidth,
						myPath.add(event.downPoint)
						myPath.arcTo(event.middlePoint, event.point)
				    myPath.selected = true
						myPath.removeOnDrag()

						checkIfBoardContains(myPath)
					}
				},
				onMouseUp: function(event) {
					myPath.selected = false
				}
		}),

		cloud: new Tool({
				minDistance: 20,
				onMouseDown: function(event) {
					myPath = new Path()
					myPath.strokeColor = currentColor
					myPath.strokeWidth = currentStrokeWidth,
					myPath.add(event.point)
				},
				onMouseDrag: function(event) {
					if(artBoard.bounds.contains(event.point)) {
  					myPath.arcTo(event.point, true)

						checkIfBoardContains(myPath)
					}
				}
		}),

		transform: new Tool({
			onMouseDown: function(event) {
				var hitOptions = {
						segments: false,
						stroke: true,
						fill: true,
						tolerance: 5
				}

				if (artBoard.bounds.contains(event.point)) {
						var hitResult = project.hitTest(event.point, hitOptions)
				}

				if (hitResult && hitResult.item !== artBoard) {
						path = hitResult.item
				}
				// movePath = hitResult.type == 'fill';
			},
			onMouseMove: function(event) {
				project.activeLayer.selected = false
				if (event.item &&
						event.item !== artBoard &&
						event.item.layer.name !== 'colorWheelLayer' &&
						artBoard.bounds.contains(event.point) ) {

						event.item.selected = true

					}
			},
			onMouseDrag: function(event) {
				if (event.item &&
						event.item !== artBoard &&
						event.item.layer.name !== 'colorWheelLayer' &&
						artBoard.bounds.contains(event.point) ) {

						path.position += event.delta

						checkIfBoardContains(path)
				}
			},
			onKeyDown: function(event) {
				if(event.key === 'up') {
					path.scale(1.2)
					checkIfBoardContains(path)
				} else if ( event.key === 'down') {
					path.scale(0.9)
					checkIfBoardContains(path)
				} else if ( event.key === 'space') {
					path.remove()
				}
			}
		}),// Move tool

		text: new Tool({
			onMouseDown: function(event) {

				if(artBoard.bounds.contains(event.point)) {
					var textPoint = event.downPoint

					newText = new PointText({
						point: textPoint,
						fillColor: currentColor,
						fontSize: 60,
						fontFamily: 'Arial Bold',
						content: ''
					})

					cursor = new Path.Line({
						from: newText.bounds.bottomRight,
						to: newText.bounds.topRight,
						strokeWidth: 1,
						strokeColor: 'red',
					})

					//fix
					cursorBlink = setInterval(function(){
						if(currentTool === 'text') {
							cursor.visible = cursor.visible ? false : true
						}
					}, 500)
				}

			},//mousedown
			onKeyDown: function(event) {

					if (event.key === 'backspace') {
						if(newText.content.length > 0) {
							var tempTxt = newText.content
							newText.content = tempTxt.substring(0, tempTxt.length - 1)
							cursor.position.x = newText.bounds.bottomRight.x + 5
						}
					} else if (event.key === 'space') {
							newText.content += ' '
							cursor.position.x = newText.bounds.bottomRight.x + 5
							checkIfBoardContains(newText)
					} else if ( 'abcdefghijklmonpqrstuvwxyz0123456789-[]:?/,~!@#$%^&*()_+-'.indexOf(event.key) > 0) {
							newText.content += event.key
							cursor.position.x = newText.bounds.bottomRight.x + 5
							checkIfBoardContains(newText)
					} else if ( event.key === 'enter') {
							clearInterval(cursorBlink)
							cursor.remove()
					}
			}//mousedown

		}),

		color: new Tool({
			onMouseDown: function(event) {
				if (artBoard.bounds.contains(event.point)) {
						var hitResult = project.hitTestAll(event.point)

						for(i=0; i<hitResult.length; i++) {
							if(hitResult[i].item.layer.name === 'colorWheelLayer') {
								currentColor = hitResult[i].item.fillColor
								ui.color.fillColor = currentColor
							}
						}
					}
			},
			onMouseMove: function(event) {
				if (artBoard.bounds.contains(event.point)) {
						var hitResult = project.hitTestAll(event.point)

						for(i=0; i<hitResult.length; i++) {
							if(hitResult[i].item.layer.name === 'colorWheelLayer') {
								var tempColor = hitResult[i].item.fillColor
							}
						}
					}

					ui.tempColorDisplay.strokeColor = tempColor
			},
			onKeyDown: function(event) {
			if(event.key === 'space')
				//activate the tool that was active before picking color
				currentTool = previousTool
				draw[currentTool].activate()

				project.layers.colorWheelLayer.visible = false
			}
		})

}//drawing tools


//NOTES
// function img() {
//
// 	var c = document.getElementById("draw");
// 	var ctx = c.getContext("2d");
// 	var img = new Image();
// 	img.onload = function() {
// 		ctx.drawImage(img, 0, 0);
// 	};
// 	img.src = 'https://cdn.sstatic.net/stackexchange/img/logos/so/so-icon.png';
//
// 	iimg = new Raster (img)
//
// 	iimg.position = view.center
// }


//fit something to a rectangular bounds
// path.fitBounds(artBoard.bounds)

// // display cordinates of an elemet
// function displayPoints(path) {


// Loop 30 times:
// for (var i = 0; i < 30; i++) {
//     // Create a circle shaped path at a random position
//     // in the view:
//     var path = new Path.Circle({
//         center: Point.random() * view.size,
//         radius: 25,
//         fillColor: 'black',
//         strokeColor: 'white'
//     });


</script> <!-- paperscript -->
</body>
</html>
