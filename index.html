<!DOCTYPE html>
<html>
<head>
<title>Mies</title>
<link href="./src/stylesheets/style.css" rel="stylesheet" type="text/css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.10.3/paper-full.js"></script>
</head>

<body>
<canvas resize id="draw"></canvas>
<script type="text/paperscript" canvas="draw" async>

/*
CONSTRUCT UI ELEMENTS
*/


//todo - move tool, color tool, delete tool
//keboard events d for delete m for move c for color
//tweet image button
var currentTool = ''
var myPath

var artBoardSize = new Size (800, 600)
var artBoardTopX = Math.max(180,(view.center.x - artBoardSize.width/2))
var artBoardPoint = new Point (artBoardTopX, view.center.y - artBoardSize.height/2)

//create an on resize view to modify position of
var artBoard = new Path.Rectangle({
	point: artBoardPoint,
	size: artBoardSize,
	strokeColor: '#cbcbcb',
	strokeWidth: .5,
	fillColor: 'ghostwhite',
	name: 'artboard',
	shadowColor: '#cbcbcb',
	shadowBlur: 30,
	shadowOffset: new Point(10, 10),
	onMouseEnter: function(event) {

	},
	onMouseDown: function(event) {
		//new line everytime we hit artboard
	},
	onMouseDrag: function(event) {
	}
})


//DRAW ALL UI ELEMENTS
var infoUi = new PointText({
		point: artBoardPoint - [0, 10],
		fillColor: 'black',
		fontSize: 14,
		content: 'Click and Drag to draw a line'
})

var lineUi = new Path.Line({
	from: [50, 100],
	to: [100, 50],
	strokeWidth: 8,
	strokeColor: 'red',
	onClick: function(event) {
		currentTool = 'line'
		draw.line.activate()
		infoUi.content = 'Click and Drag to draw a ' + currentTool
	}
})

var circleUi = new Path.Circle({
	center: [80, 150],
	radius: 30,
	fillColor: 'red',
	onClick: function(event) {
		currentTool = 'circle'
		draw.circle.activate()
		infoUi.content = 'Click and Drag to draw a ' + currentTool
	}
})

var rectUi = new Path.Rectangle({
	point: [50, 200],
	size: [60,60],
	fillColor: 'red',
	onClick: function(event) {
		currentTool = 'rectangle'
		draw.rectangle.activate()
		infoUi.content = 'Click and Drag to draw a ' + currentTool
	}
})

var arcUi = new Path.Arc({
	from: [50, 320],
	through: [80, 290],
	to: [110, 320],
	strokeColor: 'red',
	strokeWidth: 7,
	onClick: function(event) {
		currentTool = 'arc'
		draw.arc.activate()
		infoUi.content = 'Click and Drag to draw an ' + currentTool
	}
})

var cloudUi = new Path({
	segments:[[50, 370],[60, 350],[70, 370],[80, 350],
						[90, 370],[100, 350],[110,370]],
	strokeColor: 'red',
	strokeWidth: 8,
	onClick: function(event) {
		currentTool = 'cloud'
		draw.cloud.activate()
		infoUi.content = 'Click and Drag to draw a ' + currentTool
	}
})
cloudUi.simplify()

var moveUI = new Path({
	segments:[[60, 420],[110, 400],[90, 450]],
	fillColor: 'red',
	onClick: function(event) {
		currentTool = 'move'
		draw.move.activate()
		infoUi.content = 'Select and Drag to move an element or edit a point '
	}
})
// Create a UI group
var uiGroup = new Group({
	children: [lineUi, circleUi, rectUi, arcUi, cloudUi, moveUI],
	//adjust group position based on artboards position
})

uiGroup.position.y = artBoard.position.y

var segment = null
var path = null
window.draw = {
		line: new Tool({
				onMouseDown: function(event) {
							path = new Path();
							path.strokeColor = 'black'
							path.add(event.point)
					},
				onMouseDrag: function(event) {
					if(artBoard.bounds.contains(event.point)) {
						path.add(event.point)
					}
				}
		}),

		circle: new Tool({
				onMouseDrag: function(event) {
					if(artBoard.bounds.contains(event.point)) {
						var radius = (event.downPoint - event.point).length
						var circle = new Path.Circle({
								center: event.downPoint,
								radius: radius,
								name: 'circle' + this.id,
								fillColor: 'white',
								strokeColor: 'black',
						})
						//clip paths out of bounds of artBoard
						if (!artBoard.bounds.contains(circle.bounds)) {
							var clipper = new Path.Rectangle(artBoard.bounds)
							var group = new Group(clipper, circle)
									group.clipped = true
						}
						path.removeOnDrag()
					}
				}
		}),

		rectangle: new Tool({
				onMouseDrag: function(event) {
					if(artBoard.bounds.contains(event.point)) {
							// figure out to do with native rect instead of circle
							var radius = (event.downPoint - event.point).length
							var circle = new Path.Circle(event.downPoint, radius)
							var rect = new Path.Rectangle(circle.bounds)
							rect.fillColor = 'white'
							rect.strokeColor = 'black'
							rect.removeOnDrag()

							if (!artBoard.bounds.contains(rect.bounds)) {
								var clipper = new Path.Rectangle(artBoard.bounds)
								var group = new Group(clipper, rect)
										group.clipped = true
							}
					}
				}
		}),

		arc: new Tool({
				onMouseDown: function(event) {
					 	myPath = new Path() //arc tool
				},
				onMouseDrag: function(event) {
					if(artBoard.bounds.contains(event.point)) {
						myPath = new Path()
						myPath.strokeColor = 'black'
						myPath.add(event.downPoint)
						myPath.arcTo(event.middlePoint, event.point)
				    myPath.selected = true
						myPath.removeOnDrag()

						if (!artBoard.bounds.contains(myPath.bounds)) {
							var clipper = new Path.Rectangle(artBoard.bounds)
							var group = new Group(clipper, myPath)
									group.clipped = true
						}
					}
				},
				onMouseUp: function(event) {
					myPath.selected = false
					// myPath.fillColor = 'black';
				}
		}),

		cloud: new Tool({
				minDistance: 20,
				onMouseDown: function(event) {
					myPath = new Path()
					myPath.strokeColor = 'black'
					myPath.add(event.point)
				},
				onMouseDrag: function(event) {
					if(artBoard.bounds.contains(event.point)) {
  					myPath.arcTo(event.point, true)

						if (!artBoard.bounds.contains(myPath.bounds)) {
							var clipper = new Path.Rectangle(artBoard.bounds)
							var group = new Group(clipper, myPath)
									group.clipped = true
						}
					}
				}
		}),

		//from paperjs.org
		move: new Tool({
			onMouseDown: function(event) {
				var hitOptions = {
						segments: true,
						stroke: true,
						fill: true,
						tolerance: 5
				}
				var hitResult = project.hitTest(event.point, hitOptions)
				if (!hitResult)
						return;

				if (event.modifiers.shift) {
						if (hitResult.type == 'segment') {
								hitResult.segment.remove();
						};
						return;
				}

				if (hitResult) {
						path = hitResult.item;
						if (hitResult.type == 'segment') {
								segment = hitResult.segment;
						} else if (hitResult.type == 'stroke') {
								var location = hitResult.location;
								segment = path.insert(location.index + 1, event.point);
								path.smooth();
						}
				}
				// movePath = hitResult.type == 'fill';
				// if (movePath)
				// 		project.activeLayer.addChild(hitResult.item);
			},
			onMouseMove: function(event) {
				project.activeLayer.selected = false
				if (event.item &&
						event.item.name !== 'artboard' &&
						artBoard.bounds.contains(event.point)) {

						event.item.selected = true
					}
			},
			onMouseDrag: function(event) {
				if (segment &&
						event.item.name !== 'artboard' &&
						artBoard.bounds.contains(event.point) &&
						!uiGroup.bounds.contains(event.point)) {

						segment.point += event.delta;
						path.smooth();

						if (!artBoard.bounds.contains(path.bounds)) {
							var clipper = new Path.Rectangle(artBoard.bounds)
							var group = new Group(clipper, path)
									group.clipped = true
						}
				} else if (path  &&
						event.item.name !== 'artboard' &&
						artBoard.bounds.contains(event.point)&&
						!uiGroup.bounds.contains(event.point)) {

						path.position += event.delta;

						if (!artBoard.bounds.contains(path.bounds)) {
							var clipper = new Path.Rectangle(artBoard.bounds)
							var group = new Group(clipper, path)
									group.clipped = true
						}
				}
			}
		})
}//drawing tools


// //clone path horizintally
// for (var i = 0; i < 3; i++) {
// 	var copy = path.clone();
//
// // Distribute the copies horizontally, so we can see them:
// 	copy.position.x += i * copy.bounds.width;
// }

//fit something to a rectangular bounds
// path.fitBounds(artBoard.bounds)

// // display cordinates of an elemet
// function displayPoints(path) {
//
// 	var segments = path.segments
//
// 	segments.forEach(function(segment) {
// 		var x = segment.point._x
// 		var y = segment.point._y
// 		var point = new Point(x,y)
// 		var text = new PointText(point);
// 		text.fillColor = 'red';
// 		text.content = point.x + ' ' + point.y
// 		text.fontSize = 7
// 	})
// }

// Loop 30 times:
// for (var i = 0; i < 30; i++) {
//     // Create a circle shaped path at a random position
//     // in the view:
//     var path = new Path.Circle({
//         center: Point.random() * view.size,
//         radius: 25,
//         fillColor: 'black',
//         strokeColor: 'white'
//     });
//
//     // When the mouse is pressed on the item, remove it:
//

</script>
</body>
</html>
