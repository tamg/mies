<!DOCTYPE html>
<html>
<head>
<title>Mies</title>
<link href="./src/stylesheets/style.css" rel="stylesheet" type="text/css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.10.3/paper-full.js"></script>
</head>

<body>
<canvas resize id="draw"></canvas>
<script type="text/paperscript" canvas="draw" async>

/*
CONSTRUCT UI ELEMENTS
*/


//todo - move tool, color tool, delete tool
//keboard events d for delete m for move c for color
//tweet image button
var currentTool = ''
var myPath

var artBoardSize = new Size (800, 600)
var artBoardTopX = Math.max(180,(view.center.x - artBoardSize.width/2))
var artBoardPoint = new Point (artBoardTopX, view.center.y - artBoardSize.height/2)

//create an on resize view to modify position of
var artBoard = new Path.Rectangle({
	point: artBoardPoint,
	size: artBoardSize,
	strokeColor: '#cbcbcb',
	strokeWidth: .5,
	fillColor: 'ghostwhite',
	name: 'artboard',
	shadowColor: '#cbcbcb',
	shadowBlur: 30,
	shadowOffset: new Point(10, 10),
	onMouseEnter: function(event) {

	},
	onMouseDown: function(event) {
		//new line everytime we hit artboard
	},
	onMouseDrag: function(event) {
	}
})

//DRAW ALL UI ELEMENTS
var infoUi = new PointText({
		point: artBoardPoint - [0, 10],
		fillColor: 'black',
		fontSize: 16,
		content: 'Click and Drag to draw a line'
})

var lineUi = new Path.Line({
	from: [50, 100],
	to: [100, 50],
	strokeWidth: 8,
	strokeColor: 'red',
	onClick: function(event) {
		currentTool = 'line'
		draw.line.activate()
		infoUi.content = 'Click and Drag to draw a ' + currentTool
	}
})

var circleUi = new Path.Circle({
	center: [80, 150],
	radius: 30,
	fillColor: 'red',
	onClick: function(event) {
		currentTool = 'circle'
		draw.circle.activate()
		infoUi.content = 'Click and Drag to draw a ' + currentTool
	}
})

var rectUi = new Path.Rectangle({
	point: [50, 200],
	size: [60,60],
	fillColor: 'red',
	onClick: function(event) {
		currentTool = 'rectangle'
		draw.rectangle.activate()
		infoUi.content = 'Click and Drag to draw a ' + currentTool
	}
})

var arcUi = new Path.Arc({
	from: [50, 320],
	through: [80, 290],
	to: [110, 320],
	strokeColor: 'red',
	strokeWidth: 7,
	onClick: function(event) {
		currentTool = 'arc'
		draw.arc.activate()
		infoUi.content = 'Click and Drag to draw an ' + currentTool
	}
})

var cloudUi = new Path({
	segments:[[50, 370],[60, 350],[70, 370],[80, 350],
						[90, 370],[100, 350],[110,370]],
	strokeColor: 'red',
	strokeWidth: 8,
	onClick: function(event) {
		currentTool = 'cloud'
		draw.cloud.activate()
		infoUi.content = 'Click and Drag to draw a ' + currentTool
	}
})
cloudUi.simplify()

var moveUI = new Path({
	segments:[[60, 420],[110, 400],[90, 450]],
	fillColor: 'red',
	onClick: function(event) {
		currentTool = 'move'
		draw.move.activate()
		infoUi.content = 'Select and Drag to move an element or edit a point '
	}
})

var colorWheel = false
var colorUi = new Path.Circle({
	center: [80, 500],
	radius: 30,
	fillColor: 'red',
	onClick: function(event) {
		currentTool = 'color'
		showColorUi()
		draw.color.activate()
		infoUi.content = 'Click to pick a color'
	}
})

//from Paperjs.org examples
function showColorUi() {
	var steps = {
			hue: 100,
			saturation: 20,
			lightness: 3
	}

	var colorGroup = new Group()

	for (var i = 0; i < steps.lightness; i++) {
			var radius = artBoard.size.width / steps.lightness * 0.40
			var offset = new Point(artBoard.size.width / steps.lightness, 0)
			var position = artBoard.bounds.leftCenter + offset * (i + 0.5)
			var lightness = 1 - (i + 1) / (steps.lightness + 1)
			createWheel(position, radius, steps, lightness)
	}

	function createWheel(center, radius, steps, lightness) {
			var hUnit = 360 / steps.hue
			for (var h = 0; h < steps.hue; h++) {
					var hue = h * hUnit;
					var vector = new Point({
							angle: hue - 90,
							length: radius
					})
					path = new Path(new Point(), vector.rotate(hUnit / 2))
					path.closed = true
					path.arcTo(vector, vector.rotate(hUnit / -2))
					path.position += center
					var colors = []
					for (var i = 0; i < steps.saturation; i++) {
							var saturation = i / steps.saturation
							var color = { hue: hue, saturation: saturation, lightness: lightness }
							colors.push(color)
					}
					var gradient = new Gradient(colors, true);
					var from = center
					var to = center + vector
					var gradientColor = new Color(gradient, from, to)
					path.fillColor = path.strokeColor = gradientColor
					colorGroup.addChild(path)
			}
	}
	var colorGroupRect = new Path.Rectangle(colorGroup.bounds)
	colorGroupRect.strokeColor = 'red'
	colorGroupRect.scale(1.04, 1.09)

	var closeColorUi = new PointText({
			point: colorGroupRect.bounds.topLeft - [0, 10],
			fillColor: 'red',
			fontSize: 16,
			content: 'Close Color Wheel [X]',
			onClick: function(event) {
				colorGroupRect.remove()
				colorGroup.removeChildren()
				this.remove()
			}
	})

}


// Create a UI group
var uiGroup = new Group({
	children: [lineUi, circleUi, rectUi, arcUi, cloudUi, moveUI, colorUi],
	//adjust group position based on artboards position
})

uiGroup.position.y = artBoard.position.y

//DRAWING AND EDITING TOOLS
window.draw = {
		line: new Tool({
				onMouseDown: function(event) {
							path = new Path();
							path.strokeColor = 'black'
							path.add(event.point)
					},
				onMouseDrag: function(event) {
					if(artBoard.bounds.contains(event.point)) {
						path.add(event.point)
					}
				}
		}),

		circle: new Tool({
				onMouseDrag: function(event) {
					if(artBoard.bounds.contains(event.point)) {
						var radius = (event.downPoint - event.point).length
						var circle = new Path.Circle({
								center: event.downPoint,
								radius: radius,
								name: 'circle' + this.id,
								fillColor: 'white',
								strokeColor: 'black',
						})
						circle.removeOnDrag()
						//clip paths out of bounds of artBoard
						if (!artBoard.bounds.contains(circle.bounds)) {
							var clipper = new Path.Rectangle(artBoard.bounds)
							var group = new Group(clipper, circle)
									group.clipped = true
						}
					}
				}
		}),

		rectangle: new Tool({
				onMouseDrag: function(event) {
					if(artBoard.bounds.contains(event.point)) {
							// figure out to do with native rect instead of circle
							var radius = (event.downPoint - event.point).length
							var circle = new Path.Circle(event.downPoint, radius)
							var rect = new Path.Rectangle(circle.bounds)
							rect.fillColor = 'white'
							rect.strokeColor = 'black'
							rect.removeOnDrag()

							if (!artBoard.bounds.contains(rect.bounds)) {
								var clipper = new Path.Rectangle(artBoard.bounds)
								var group = new Group(clipper, rect)
										group.clipped = true
							}
					}
				}
		}),

		arc: new Tool({
				onMouseDown: function(event) {
					 	myPath = new Path() //arc tool
				},
				onMouseDrag: function(event) {
					if(artBoard.bounds.contains(event.point)) {
						myPath = new Path()
						myPath.strokeColor = 'black'
						myPath.add(event.downPoint)
						myPath.arcTo(event.middlePoint, event.point)
				    myPath.selected = true
						myPath.removeOnDrag()

						if (!artBoard.bounds.contains(myPath.bounds)) {
							var clipper = new Path.Rectangle(artBoard.bounds)
							var group = new Group(clipper, myPath)
									group.clipped = true
						}
					}
				},
				onMouseUp: function(event) {
					myPath.selected = false
				}
		}),

		cloud: new Tool({
				minDistance: 20,
				onMouseDown: function(event) {
					myPath = new Path()
					myPath.strokeColor = 'black'
					myPath.add(event.point)
				},
				onMouseDrag: function(event) {
					if(artBoard.bounds.contains(event.point)) {
  					myPath.arcTo(event.point, true)

						if (!artBoard.bounds.contains(myPath.bounds)) {
							var clipper = new Path.Rectangle(artBoard.bounds)
							var group = new Group(clipper, myPath)
									group.clipped = true
						}
					}
				}
		}),

		move: new Tool({
			onMouseDown: function(event) {
				var hitOptions = {
						segments: false,
						stroke: true,
						fill: true,
						tolerance: 5
				}

				if (artBoard.bounds.contains(event.point)) {
						var hitResult = project.hitTest(event.point, hitOptions)
					}

				if (hitResult && hitResult.item !== artBoard) {
						path = hitResult.item
				}
				// movePath = hitResult.type == 'fill';
				// if (movePath)
				// 		project.activeLayer.addChild(hitResult.item);
			},
			onMouseMove: function(event) {
				project.activeLayer.selected = false
				if (event.item &&
						event.item !== artBoard &&
						artBoard.bounds.contains(event.point)) {

						event.item.selected = true

					}
			},
			onMouseDrag: function(event) {
				if (event.item &&
						event.item !== artBoard &&
						artBoard.bounds.contains(event.point)) {

						path.position += event.delta

						if (!artBoard.bounds.contains(path.bounds)) {
							var clipper = new Path.Rectangle(artBoard.bounds)
							var group = new Group(clipper, path)
									group.clipped = true
						}
				}
			}
		}),// Move tool

		color: new Tool({
		})
}//drawing tools

//handle view on a resize event
// view.on('resize', function() {
//
// 		artBoard.fitBounds(this.bounds)
// 		artBoard.scale(.7)
// });

// //clone path horizintally
// for (var i = 0; i < 3; i++) {
// 	var copy = path.clone();
//
// // Distribute the copies horizontally, so we can see them:
// 	copy.position.x += i * copy.bounds.width;
// }

//fit something to a rectangular bounds
// path.fitBounds(artBoard.bounds)

// // display cordinates of an elemet
// function displayPoints(path) {
//
// 	var segments = path.segments
//
// 	segments.forEach(function(segment) {
// 		var x = segment.point._x
// 		var y = segment.point._y
// 		var point = new Point(x,y)
// 		var text = new PointText(point);
// 		text.fillColor = 'red';
// 		text.content = point.x + ' ' + point.y
// 		text.fontSize = 7
// 	})
// }

// Loop 30 times:
// for (var i = 0; i < 30; i++) {
//     // Create a circle shaped path at a random position
//     // in the view:
//     var path = new Path.Circle({
//         center: Point.random() * view.size,
//         radius: 25,
//         fillColor: 'black',
//         strokeColor: 'white'
//     });
//
//     // When the mouse is pressed on the item, remove it:
//

</script>
</body>
</html>
