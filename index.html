<!DOCTYPE html>
<html>
<head>
<title>Mies</title>
<link href="./src/stylesheets/style.css" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/emojione/2.2.7/assets/css/emojione.min.css"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.10.3/paper-full.js"></script>
<script src="https://cdn.jsdelivr.net/emojione/2.2.7/lib/js/emojione.min.js"></script>
</head>

<body>
<canvas resize id="draw"></canvas>
<script type="text/paperscript" canvas="draw" async>

//when close color wheel is clicked it should reactivate previous tool using currentool

//todo - move tool, color tool, delete tool
//keboard events d for delete m for move c for color
//tweet image button
//create an on resize view to modify position of

/*
CONSTRUCT PROJECT LAYERS
*/
//the layer where most things are inside of
var baseLayer = new Layer({
	name: 'baseLayer'
})

//layer to hold the colorwheel tool
var colorWheelLayer = new Layer({
	name: 'colorWheelLayer'
})

//activate baseLayer
baseLayer.activate()

var currentColor = 'black'
var tempColorDisplay

var previousTool = ''
var currentTool = 'line'
var myPath

//draw our artboard based on browser window size (view)
var artBoardSize = new Size (800, 600)
var artBoardTopX = Math.max(180,(view.center.x - artBoardSize.width/2))
var artBoardPoint = new Point (artBoardTopX, view.center.y - artBoardSize.height/2)

var artBoard = new Path.Rectangle({
	point: artBoardPoint,
	size: artBoardSize,
	strokeColor: '#cbcbcb',
	strokeWidth: .5,
	fillColor: 'ghostwhite',
	name: 'artboard',
	shadowColor: '#cbcbcb',
	shadowBlur: 30,
	shadowOffset: new Point(10, 10),
})

// helper function to check/clip if a drawn object is inside the bounds of an artBoard
// TODO: figure out layer index issue
function checkIfBoardContains(object) {
	if (!artBoard.bounds.contains(object.bounds)) {
		var clipper = new Path.Rectangle(artBoard.bounds)
		var clippedGroup = new Group(clipper, object)
				clippedGroup.clipped = true
	}
}

//draw all the ui elements
var ui = {

	info: new PointText({
		point: artBoardPoint - [0, 10],
		fillColor: 'black',
		fontSize: 16,
		content: 'Click and Drag to draw a line'
	}),

	line: new Path.Line({
		from: [50, 100],
		to: [100, 50],
		strokeWidth: 8,
		strokeColor: 'red',
		onClick: function(event) {
			currentTool = 'line'
			draw.line.activate()
			ui.info.content = 'Click and Drag to draw a ' + currentTool
		}
	}),

	circle: new Path.Circle({
		center: [80, 150],
		radius: 30,
		fillColor: 'red',
		onClick: function(event) {
			currentTool = 'circle'
			draw.circle.activate()
			ui.info.content = 'Click and Drag to draw a ' + currentTool
		}
	}),

	rect: new Path.Rectangle({
		point: [50, 200],
		size: [60,60],
		fillColor: 'red',
		onClick: function(event) {
			currentTool = 'rectangle'
			draw.rectangle.activate()
			ui.info.content = 'Click and Drag to draw a ' + currentTool
		}
	}),

	arc: new Path.Arc({
		from: [50, 320],
		through: [80, 290],
		to: [110, 320],
		strokeColor: 'red',
		strokeWidth: 7,
		onClick: function(event) {
			currentTool = 'arc'
			draw.arc.activate()
			ui.info.content = 'Click and Drag to draw an ' + currentTool
		}
	}),

	cloud: new Path({
		segments:[[50, 370],[60, 350],[70, 370],[80, 350],
		[90, 370],[100, 350],[110,370]],
		strokeColor: 'red',
		strokeWidth: 8,
		onClick: function(event) {
			currentTool = 'cloud'
			draw.cloud.activate()
			ui.info.content = 'Click and Drag to draw a ' + currentTool
		}
	}),

	text: new PointText({
		point: [60, 450],
		fillColor: 'red',
		fontSize: 70,
		fontFamily: 'Arial Bold',
		content: 'T',
		onClick: function(event) {
			currentTool = 'text'
			draw.text.activate()
			ui.info.content = 'Click to insert text and type'
		}
	}),

	transform: new Path({
		segments:[[60, 490],[110, 470],[90, 520], [83, 497]],
		fillColor: 'red',
		onClick: function(event) {
			currentTool = 'transform'
			draw.transform.activate()
			ui.info.content = 'First select object.Then Mouse Drag to move. UP / DOWN Arrow to scale UP / DOWN'
		}
	}),

	color: new Path.Circle({
		center: [80, 570],
		radius: 30,
		fillColor: 'red',
		strokeColor: 'black',
		strokeWidth: 2,
		onClick: function(event) {
			tempColorDisplay = new Path.Line({
				from: artBoard.bounds.bottomLeft,
				to: artBoard.bounds.bottomRight,
				strokeWidth: 30
			})
			previousTool = currentTool
			currentTool = 'color'
			showColorUi()
			draw.color.activate()
			project.layers.colorWheelLayer.visible = true
			ui.info.content = 'Click to pick a color'
		}
	})
}//window.ui

//add curvature to cloud ui
ui.cloud.simplify()

//modified from Paperjs.org examples
function showColorUi() {

	colorWheelLayer.activate()
	var steps = {
			hue: 24,
			saturation: 5,
			lightness: 3
	}

	var colorGroup = new Group()

	//lightness
	for (var l = 0; l < steps.lightness; l++) {
		var radius = artBoard.size.width / steps.lightness * 0.40
		var offset = new Point(artBoard.size.width / steps.lightness, 0)
		var center = artBoard.bounds.leftCenter + offset * (l + 0.5)
		var lightness = 1 - (l + 1) / (steps.lightness + 1)

		//hue
		var hUnit = 360 / steps.hue
		for (var h = 0; h < steps.hue; h++) {
			var hue = h * hUnit;
			var vector = new Point({
					angle: hue - 90,
					length: radius
			})

			colorPath = new Path(new Point(), vector.rotate(hUnit / 2))
			colorPath.closed = true
			colorPath.arcTo(vector, vector.rotate(hUnit / -2))
			colorPath.position += center

			//saturation
			for (var i = 0; i < steps.saturation; i++) {
					var saturation = i / steps.saturation
					var color = { hue: hue, saturation: saturation, lightness: lightness }
			}

			colorPath.fillColor = colorPath.strokeColor = color
			colorPath.name = 'colorPath' + colorPath.id
			project.layers.colorWheelLayer.addChild(colorPath)
			colorGroup.addChild(colorPath)
		}

	//activate the base layer back after creating colorWheelLayer
	baseLayer.activate()
}
}//showColorUi()

// Create a UI group
var uiGroup = new Group({
	children: [ui.line, ui.circle, ui.rect, ui.arc, ui.cloud, ui.text, ui.transform, ui.color],
	//adjust group position based on artboards position
})

uiGroup.position.y = artBoard.position.y

//DRAWING AND EDITING TOOLS
window.draw = {
		line: new Tool({
				onMouseDown: function(event) {
							path = new Path();
							path.strokeColor = currentColor
							path.add(event.point)
					},
				onMouseDrag: function(event) {
					if(artBoard.bounds.contains(event.point)) {
						path.add(event.point)
					}
				}
		}),

		circle: new Tool({
				onMouseDrag: function(event) {
					if(artBoard.bounds.contains(event.point)) {
						var radius = (event.downPoint - event.point).length
						var circle = new Path.Circle({
								center: event.downPoint,
								radius: radius,
								name: 'circle' + this.id,
								fillColor: currentColor,
								strokeColor: 'black',
						})
						circle.removeOnDrag()
						checkIfBoardContains(circle)
					}
				}
		}),

		rectangle: new Tool({
				onMouseDrag: function(event) {
					if(artBoard.bounds.contains(event.point)) {
							// figure out to do with native rect instead of circle
							var radius = (event.downPoint - event.point).length
							var circle = new Path.Circle(event.downPoint, radius)
							var rect = new Path.Rectangle(circle.bounds)
							rect.fillColor = currentColor
							rect.strokeColor = 'black'
							rect.removeOnDrag()

							checkIfBoardContains(rect)

							circle.remove()
					}
				}
		}),

		arc: new Tool({
				onMouseDown: function(event) {
					 	myPath = new Path() //arc tool
				},
				onMouseDrag: function(event) {
					if(artBoard.bounds.contains(event.point)) {
						myPath = new Path()
						myPath.strokeColor = currentColor
						myPath.add(event.downPoint)
						myPath.arcTo(event.middlePoint, event.point)
				    myPath.selected = true
						myPath.removeOnDrag()

						checkIfBoardContains(myPath)
					}
				},
				onMouseUp: function(event) {
					myPath.selected = false
				}
		}),

		cloud: new Tool({
				minDistance: 20,
				onMouseDown: function(event) {
					myPath = new Path()
					myPath.strokeColor = currentColor
					myPath.add(event.point)
				},
				onMouseDrag: function(event) {
					if(artBoard.bounds.contains(event.point)) {
  					myPath.arcTo(event.point, true)

						checkIfBoardContains(myPath)
					}
				}
		}),

		transform: new Tool({
			onMouseDown: function(event) {
				var hitOptions = {
						segments: false,
						stroke: true,
						fill: true,
						tolerance: 5
				}

				if (artBoard.bounds.contains(event.point)) {
						var hitResult = project.hitTest(event.point, hitOptions)
				}

				if (hitResult && hitResult.item !== artBoard) {
						path = hitResult.item
				}
				// movePath = hitResult.type == 'fill';
			},
			onMouseMove: function(event) {
				project.activeLayer.selected = false
				if (event.item &&
						event.item !== artBoard &&
						artBoard.bounds.contains(event.point)) {

						event.item.selected = true

					}
			},
			onMouseDrag: function(event) {
				if (event.item &&
						event.item !== artBoard &&
						artBoard.bounds.contains(event.point)) {

						path.position += event.delta

						checkIfBoardContains(path)
				}
			},
			onKeyDown: function(event) {
				if(event.key === 'up') {
					path.scale(1.2)
					checkIfBoardContains(path)
				} else if ( event.key === 'down') {
					path.scale(0.9)
					checkIfBoardContains(path)
				}
			}
		}),// Move tool

		text: new Tool({
			onMouseDown: function(event) {

				if(artBoard.bounds.contains(event.point)) {
					var textPoint = event.downPoint

					newText = new PointText({
						point: textPoint,
						fillColor: currentColor,
						fontSize: 50,
						fontFamily: 'Arial Bold',
						content: ''
					})

					cursor = new Path.Line({
						from: newText.bounds.bottomRight,
						to: newText.bounds.topRight,
						strokeWidth: 1,
						strokeColor: 'red',
					})

					//fix
					cursorBlink = setInterval(function(){
						if(currentTool === 'text') {
							cursor.visible = cursor.visible ? false : true
						}
					}, 500)
				}

			},//mousedown
			onKeyDown: function(event) {

					if (event.key === 'backspace') {
						if(newText.content.length > 0) {
							var tempTxt = newText.content
							newText.content = tempTxt.substring(0, tempTxt.length - 1)
							cursor.position.x = newText.bounds.bottomRight.x + 5
						}
					} else if (event.key === 'space') {
							newText.content += ' '
							cursor.position.x = newText.bounds.bottomRight.x + 5
							checkIfBoardContains(newText)
					} else if ( 'abcdefghijklmonpqrstuvwxyz0123456789-[]:?/,~!@#$%^&*()_+-'.indexOf(event.key) > 0) {
							newText.content += event.key
							cursor.position.x = newText.bounds.bottomRight.x + 5
							checkIfBoardContains(newText)
					} else if ( event.key === 'enter') {
							clearInterval(cursorBlink)
							cursor.remove()
					}
			}//mousedown

		}),

		//add delete tool with click and delete key

		color: new Tool({
			onMouseDown: function(event) {
				if (artBoard.bounds.contains(event.point)) {
						var hitResult = project.hitTestAll(event.point)

						for(i=0; i<hitResult.length; i++) {
							if(hitResult[i].item.layer.name === 'colorWheelLayer') {
								currentColor = hitResult[i].item.fillColor
								ui.color.fillColor = currentColor
							}
						}

					}
			},
			onMouseMove: function(event) {
				if (artBoard.bounds.contains(event.point)) {
						var hitResult = project.hitTestAll(event.point)

						for(i=0; i<hitResult.length; i++) {
							if(hitResult[i].item.layer.name === 'colorWheelLayer') {
								var tempColor = hitResult[i].item.fillColor
							}
						}
					}

					tempColorDisplay.strokeColor = tempColor
			},
			onKeyDown: function(event) {
			if(event.key === 'space')
				//activate the tool that was active before picking color
				currentTool = previousTool
				draw[currentTool].activate()

				project.layers.colorWheelLayer.visible = false
			}
		})
}//drawing tools

//handle view on a resize event
// view.on('resize', function() {
//
// 		artBoard.fitBounds(this.bounds)
// 		artBoard.scale(.7)
// });

// //clone path horizintally
// for (var i = 0; i < 3; i++) {
// 	var copy = path.clone();
//
// // Distribute the copies horizontally, so we can see them:
// 	copy.position.x += i * copy.bounds.width;
// }

//fit something to a rectangular bounds
// path.fitBounds(artBoard.bounds)

// // display cordinates of an elemet
// function displayPoints(path) {
//
// 	var segments = path.segments
//
// 	segments.forEach(function(segment) {
// 		var x = segment.point._x
// 		var y = segment.point._y
// 		var point = new Point(x,y)
// 		var text = new PointText(point);
// 		text.fillColor = 'red';
// 		text.content = point.x + ' ' + point.y
// 		text.fontSize = 7
// 	})
// }

// Loop 30 times:
// for (var i = 0; i < 30; i++) {
//     // Create a circle shaped path at a random position
//     // in the view:
//     var path = new Path.Circle({
//         center: Point.random() * view.size,
//         radius: 25,
//         fillColor: 'black',
//         strokeColor: 'white'
//     });
//
//     // When the mouse is pressed on the item, remove it:
//



// var raster = new Raster({
//     source: img.src,
//     position: view.center
// });


</script>


</body>
</html>
